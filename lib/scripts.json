{
  "darwin": {
    "content": "#!/bin/bash\n\nset -u\nset -e\n\nget_key() {\n\n  # This expression is intentionally unquoted so that\n  # multiple lines get joined as a single one.\n  # See https://github.com/resin-io-modules/drivelist/pull/129\n  echo $(grep \"$1\" | awk -F \"  +\" '{ print $3 }')\n\n}\n\nget_until_paren() {\n  awk 'match($0, \"\\\\(|$\"){ print substr($0, 0, RSTART - 1) }'\n}\n\nDISKS=\"$(diskutil list | grep '^\\/' | get_until_paren)\"\nmount_output=\"$(mount)\"\n\nfor disk in $DISKS; do\n\n  # Ignore drives that were just unplugged\n  if ! diskinfo=\"$(diskutil info \"$disk\")\"; then\n    continue\n  fi\n\n  device=\"$(echo \"$diskinfo\" | get_key \"Device Node\")\"\n\n  # See http://superuser.com/q/631592\n  raw_device=\"${device//disk/rdisk}\"\n\n  description=\"$(echo \"$diskinfo\" | get_key \"Device / Media Name\")\"\n  volume_name=\"$(echo \"$diskinfo\" | get_key \"Volume Name\")\"\n  removable=\"$(echo \"$diskinfo\" | get_key \"Removable Media\")\"\n  protected=\"$(echo \"$diskinfo\" | get_key \"Read-Only Media\")\"\n  location=\"$(echo \"$diskinfo\" | get_key \"Device Location\")\"\n  size=\"$(echo \"$diskinfo\" | sed 's/Disk Size/Total Size/g' | get_key \"Total Size\" | cut -d '(' -f 2 | cut -d ' ' -f 1)\"\n\n  mountpoints=\"$(echo \"$mount_output\" | perl -n -e'm{^'\"${disk}\"'(s[0-9]+)? on (.*) \\(.*\\)$} && print \"$2\\n\"')\"\n\n  # Omit mounted DMG images\n  if [[ \"$description\" == \"Disk Image\" ]]; then\n    continue\n  fi\n\n  echo \"device: $device\"\n\n  if [[ $volume_name =~ .*Not\\ applicable.* ]]; then\n    echo \"description: \\\"$description\\\"\"\n  else\n    echo \"description: \\\"$volume_name - $description\\\"\"\n  fi\n\n  echo \"size: $size\"\n\n  if [[ -z \"$mountpoints\" ]]; then\n    echo \"mountpoints: []\"\n  else\n    echo \"mountpoints:\"\n    echo \"$mountpoints\" | while read -r mountpoint ; do\n      echo \"  - path: \\\"$mountpoint\\\"\"\n    done\n  fi\n\n  echo \"raw: $raw_device\"\n\n  if [[ \"$protected\" == \"Yes\" ]]; then\n    echo \"protected: True\"\n  else\n    echo \"protected: False\"\n  fi\n\n  if [[ \"$device\" == \"/dev/disk0\" ]] || \\\n     [[ ( \"$removable\" == \"No\" ) || (\"$removable\" == \"Fixed\") ]] || \\\n     [[ ( \"$location\" =~ \"Internal\" ) && ( \"$removable\" != \"Yes\" ) && ( \"$removable\" != \"Removable\" ) ]] || \\\n     echo \"$mountpoints\" | grep \"^/$\"\n  then\n    echo \"system: True\"\n  else\n    echo \"system: False\"\n  fi\n\n  echo \"\"\ndone\n",
    "originalFilename": "darwin.sh",
    "type": "text"
  },
  "linux": {
    "content": "#!/bin/bash\n\nset -u\nset -e\n\nignore_first_line() {\n  tail -n +2\n}\n\nget_uuids() {\n  /sbin/blkid -s UUID -o value \"$1\"*\n}\n\nget_mountpoints() {\n  grep \"^$1\" /proc/mounts | cut -d ' ' -f 2 | sed 's,\\\\040, ,g' | sed 's,\\\\011,\\t,g' | sed 's,\\\\012,\\\\n,g' | sed 's,\\\\134,\\\\\\\\,g'\n}\n\nDISKS=\"$(lsblk -d --output NAME | ignore_first_line)\"\n\nfor disk in $DISKS; do\n\n  # Omit loop devices and CD/DVD drives\n  if [[ $disk == loop* ]] || [[ $disk == sr* ]]; then\n    continue\n  fi\n\n  device=\"/dev/$disk\"\n  diskinfo=($(lsblk -b -d \"$device\" --output SIZE,RO,RM,MODEL | ignore_first_line))\n\n  # Omit drives for which `lsblk` failed, which means they\n  # were unplugged right after we got the list of all drives\n  if [ -z \"${diskinfo-}\" ]; then\n    continue\n  fi\n\n  size=${diskinfo[0]}\n  protected=${diskinfo[1]}\n  removable=${diskinfo[2]}\n  description=${diskinfo[*]:3}\n  mountpoints=\"$(get_mountpoints \"$device\")\"\n\n  # If we couldn't get the mount points as `/dev/$disk`,\n  # get the disk UUIDs, and check as `/dev/disk/by-uuid/$uuid`\n  if [ -z \"$mountpoints\" ]; then\n    for uuid in $(get_uuids \"$device\"); do\n      mountpoints=\"$mountpoints$(get_mountpoints \"/dev/disk/by-uuid/$uuid\")\"\n    done\n  fi\n\n  # If we couldn't get the description from `lsblk`, see if we can get it\n  # from sysfs (e.g. PCI-connected SD cards that appear as `/dev/mmcblk0`)\n  if [ -z \"$description\" ]; then\n    subdevice=\"$(echo \"$device\" | cut -d '/' -f 3)\"\n    if [ -f \"/sys/class/block/$subdevice/device/name\" ]; then\n      description=\"$(cat \"/sys/class/block/$subdevice/device/name\")\"\n    fi\n  fi\n\n  echo \"device: $device\"\n  echo \"description: \\\"$description\\\"\"\n  echo \"size: $size\"\n\n  if [ -z \"$mountpoints\" ]; then\n    echo \"mountpoints: []\"\n  else\n    echo \"mountpoints:\"\n    echo \"$mountpoints\" | while read -r mountpoint ; do\n      echo \"  - path: \\\"$mountpoint\\\"\"\n    done\n  fi\n\n  echo \"raw: $device\"\n\n  if [[ \"$protected\" == \"1\" ]]; then\n    echo \"protected: True\"\n  else\n    echo \"protected: False\"\n  fi\n\n  eval \"$(udevadm info \\\n    --query=property \\\n    --export \\\n    --export-prefix=UDEV_ \\\n    --name=\"$disk\" \\\n    | awk -F= '{gsub(\"\\\\.\",\"_\",$1); print $1 \"=\" $2}')\"\n\n  set +u\n\n  if [[ \"$removable\" == \"1\" ]] && \\\n     [[ \"$UDEV_ID_DRIVE_FLASH_SD\" == \"1\" ]] || \\\n     [[ \"$UDEV_ID_DRIVE_MEDIA_FLASH_SD\" == \"1\" ]] || \\\n     [[ \"$UDEV_ID_BUS\" == \"usb\" ]]\n  then\n    echo \"system: False\"\n  else\n    echo \"system: True\"\n  fi\n\n  set -u\n\n  # Unset UDEV variables used above to prevent them from\n  # being interpreted as properties of another drive\n  unset UDEV_ID_DRIVE_FLASH_SD\n  unset UDEV_ID_DRIVE_MEDIA_FLASH_SD\n  unset UDEV_ID_BUS\n\n  echo \"\"\ndone\n",
    "originalFilename": "linux.sh",
    "type": "text"
  },
  "win32": {
    "content": "<!-- : Begin batch script\n@echo off\n\n:: Ensure System32 is in the PATH, to avoid weird\n:: 'cscript' is not recognized as an internal or external command\"\" errors.\n\n:: We double quote the whole thing to prevent file\n:: name spaces from messing up the PATH variable.\n:: See https://github.com/cmderdev/cmder/issues/443#issuecomment-150202124\nset \"PATH=%PATH%;%SYSTEMROOT%\\System32\"\n\ncscript //nologo \"%~f0?.wsf\"\nexit /b %ERRORLEVEL%\n\n----- Begin wsf script --->\n<job><script language=\"VBScript\">\n\nClass List\n\tPrivate Dictionary\n\n\tPrivate Sub Class_Initialize()\n\t\tSet Dictionary = CreateObject(\"Scripting.Dictionary\")\n\tEnd Sub\n\n\tPublic Sub Add(element)\n\t\tDictionary.Add element, \"\"\n\tEnd Sub\n\n\tPublic Function GetArray()\n\t\tGetArray = Dictionary.Keys()\n\tEnd Function\n\n\tPublic Function Count\n\t\tCount = UBound(Dictionary.Keys()) + 1\n\tEnd Function\n\n\t' Only works for simple types (e.g: not objects)\n\tPublic Function Has(element)\n\t\tResult = False\n\t\tFor Each Key In Dictionary.Keys()\n\t\t\tIf Key = Element Then\n\t\t\t\tResult = True\n\t\t\tEnd If\n\t\tNext\n\t\tHas = Result\n\tEnd Function\nEnd Class\n\nSet WMIService = GetObject(\"winmgmts:\\\\.\\root\\cimv2\")\n\nFunction BooleanToString(ByVal Value)\n\tIf Value Then\n\t\tBooleanToString = \"True\"\n\tElse\n\t\tBooleanToString = \"False\"\n\tEnd If\nEnd Function\n\nFunction GetOperatingSystemDevice()\n\tSet OperatingSystemsColumn = WMIService.ExecQuery(\"SELECT SystemDrive FROM Win32_OperatingSystem\")\n\tErr.Clear\n\tFor Each OperatingSystem in OperatingSystemsColumn\n\t\tOn Error Resume Next\n\t\tGetOperatingSystemDevice = OperatingSystem.Properties_(\"SystemDrive\")\n\t\tIf Err.Number <> 0 Then\n\t\t\tGetOperatingSystemDevice = Nothing\n\t\t\tErr.Clear\n\t\tEnd If\n\tNext\nEnd Function\n\nFunction IsWMIObjectValid(WMIObject)\n\tOn Error Resume Next\n\tColumns = WMIObject.Count\n\tIsWMIObjectValid = True\n\tIf (Err.Number <> 0) Then\n\t\tIsWMIobjectValid = False\n\tEnd If\n\tOn Error Goto 0\nEnd Function\n\nFunction GetLogicalDisks(ByVal DriveDevice)\n\tSet DrivePartitionsColumn = WMIService.ExecQuery _\n\t\t(\"ASSOCIATORS OF {Win32_DiskDrive.DeviceID=\"\"\" & _\n\t\t\tDriveDevice & \"\"\"} WHERE AssocClass = \" & _\n\t\t\t\t\"Win32_DiskDriveToDiskPartition\")\n\n\tIf Not IsWMIObjectValid(DrivePartitionsColumn) Then\n\t\tSet GetLogicalDisks = Nothing\n\tElse\n\t\tSet GetLogicalDisks = new List\n\t\tFor Each DrivePartition In DrivePartitionsColumn\n\t\t\tSet DriveLogicalDisksColumn = WMIService.ExecQuery _\n\t\t\t\t(\"ASSOCIATORS OF {Win32_DiskPartition.DeviceID=\"\"\" & _\n\t\t\t\t\tDrivePartition.DeviceID & \"\"\"} WHERE AssocClass = \" & _\n\t\t\t\t\t\t\"Win32_LogicalDiskToPartition\")\n\n\t\t\tFor Each DriveLogicalDisk In DriveLogicalDisksColumn\n\t\t\t\tSet LogicalDisk = CreateObject(\"Scripting.Dictionary\")\n\n\t\t\t\t' Windows might assign a drive letter to partitions that\n\t\t\t\t' don't contain a file-system for some reason.\n\t\t\t\t' After some experimentation, it seems that we can filter\n\t\t\t\t' those out by checking if the partition size is null\n\t\t\t\tIf Not IsNull(DriveLogicalDisk.Size) Then\n\t\t\t\t\tLogicalDisk.Add \"Device\", DriveLogicalDisk.DeviceID\n\t\t\t\t\tLogicalDisk.Add \"IsProtected\", DriveLogicalDisk.Access = 1\n\t\t\t\t\tGetLogicalDisks.Add(LogicalDisk)\n\t\t\t\tEnd If\n\t\t\tNext\n\t\tNext\n\tEnd If\nEnd Function\n\nFunction GetTopLevelDrives()\n\tOperatingSystemDevice = GetOperatingSystemDevice()\n\tSet GetTopLevelDrives = new List\n\tSet TopLevelDrivesColumn = WMIService.ExecQuery(\"SELECT * FROM Win32_DiskDrive\")\n\n\tFor Each TopLevelDrive In TopLevelDrivesColumn\n\t\tSet Summary = CreateObject(\"Scripting.Dictionary\")\n\t\tDeviceID = Replace(TopLevelDrive.DeviceID, \"\\\", \"\\\\\")\n\t\tSet LogicalDisks = GetLogicalDisks(DeviceID)\n\n\t\tIf Not LogicalDisks Is Nothing Then\n\t\t\tSummary.Add \"Device\", DeviceID\n\t\t\tSummary.Add \"Description\", TopLevelDrive.Caption\n\t\t\tSummary.Add \"Size\", TopLevelDrive.Size\n\n\t\t\tSet Mountpoints = new List\n\t\t\tIsRemovable = InStr(TopLevelDrive.MediaType, \"Removable\") = 1\n\t\t\tIsProtected = False\n\n\t\t\tFor Each LogicalDisk In LogicalDisks.GetArray()\n\t\t\t\tIf Not Mountpoints.Has(LogicalDisk.Item(\"Device\")) Then\n\t\t\t\t\tMountpoints.Add(LogicalDisk.Item(\"Device\"))\n\t\t\t\tEnd If\n\n\t\t\t\tIf LogicalDisk.Item(\"IsProtected\") Then\n\t\t\t\t\tIsProtected = True\n\t\t\t\tEnd If\n\n\t\t\t\tIf LogicalDisk.Item(\"Device\") = OperatingSystemDevice Then\n\t\t\t\t\tIsRemovable = False\n\t\t\t\tEnd If\n\t\t\tNext\n\n\t\t\tSummary.Add \"Mountpoints\", Mountpoints\n\t\t\tSummary.Add \"IsRemovable\", IsRemovable\n\t\t\tSummary.Add \"IsProtected\", IsProtected\n\n\t\t\t' Windows might always list internal SD Card\n\t\t\t' readers, even when there are no cards inserted.\n\t\t\t' A realiable way to omit these drives is to\n\t\t\t' check whether the size is null\n\t\t\tIf Not IsNull(Summary.Item(\"Size\")) Then\n\t\t\t\tGetTopLevelDrives.Add(Summary)\n\t\t\tEnd If\n\t\tEnd If\n\tNext\nEnd Function\n\nFor Each TopLevelDrive In GetTopLevelDrives().GetArray()\n\tWscript.Echo \"device: \"\"\" & TopLevelDrive.Item(\"Device\") & \"\"\"\"\n\tWscript.Echo \"description: \"\"\" & TopLevelDrive.Item(\"Description\") & \"\"\"\"\n\tWscript.Echo \"size: \" & TopLevelDrive.Item(\"Size\")\n\tWscript.Echo \"raw: \"\"\" & TopLevelDrive.Item(\"Device\") & \"\"\"\"\n\tWscript.Echo \"system: \" & BooleanToString(Not TopLevelDrive.Item(\"IsRemovable\"))\n\tWscript.Echo \"protected: \" & BooleanToString(TopLevelDrive.Item(\"IsProtected\"))\n\n\tIf TopLevelDrive.Item(\"Mountpoints\").Count = 0 Then\n\t\tWscript.Echo \"mountpoints: []\"\n\tElse\n\t\tWscript.Echo \"mountpoints:\"\n\t\tFor Each Mountpoint In TopLevelDrive.Item(\"Mountpoints\").GetArray()\n\t\t\tWscript.Echo \"  - path: \"\"\" & Mountpoint & \"\"\"\"\n\t\tNext\n\tEnd If\n\n\tWscript.Echo \"\"\nNext\n</script></job>\n",
    "originalFilename": "win32.bat",
    "type": "text"
  }
}